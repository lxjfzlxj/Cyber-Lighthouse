### 10.2

首先我不知道要 C++ 用什么后端框架写服务器端，在 google 上搜了下，好像 crow 框架最受欢迎，就准备用这个。

去官网下 crow，发现解压完不会安装，查了一通发现要 cmake，又查了一通 cmake 怎么用。结果发现自己 linux 上没有 cmake，又去官网下，这样套娃了几层我也忘记了。

终于配置好 crow，看官方 tutorial 写了一个最简单的服务端，能在本机的某个端口整一个网站输出 `hello,world`。

然后想先去完成客户端，一开始想用一些第三方库，但是发现这些很多很小众，看官方文档也很吃力，就想直接用 C++ 自带的 `<sys/socket.h>`，在网上找了很多份最简单的代码，然后对着代码里的函数到官方文档里查使用方法，还是花了挺大劲最终写出了大致符合要求的客户端。

这时候回来写服务端，去查 crow 怎么整 tcp/udp 协议，结果发现这事很困难，crow 是基于 http 协议的框架，很难支持 tcp/udp。很崩溃，于是找了 Boost.Asio 库当后端框架，一顿学，一顿写，中间诸如编译不成功的小麻烦发生了很多。

写完用 tcp 传输的部分后测试了一下，发现客户端与服务端连接上了，可是服务端返回的数据是一团乱码。一度以为是客户端写错了，网上查也查不到相关，调试也不会，走投无路把代码仍给 ChatGPT 调，居然还真调出来了，我在客户端接收和发送数据的时候都是用 `char *data;`，而这样会出错，应当用`char data[100];` 这样的。因为前者只定义指针而没有分配内存空间，导致 send 和 read 发生未定义行为。

最后写好了 TCP 协议传输的部分，但是卡在了不知道在服务端怎么判断 TCP 包还是 UDP 包的问题。自己整了一个骚操作，如果是 UDP 包就先发一个 TCP 包放特定数据表明接下来要发 UDP 包。。太离谱了，问了出题人才知道一般这俩在两个不同端口监听。。准备明天再重构一下代码。

今天大概花了 $7\sim 8$ 个小时学。

### 10.3

一开始在想怎么同时在服务端处理 UDP 和 TCP，但是始终不太能学会用 asio 库来做这个，花了很长时间最后放弃了。后来就干脆不用后端框架了，直接学用 C++ socket 写，结果发现写起来跟客户端差不多，好写多了。再把 Task 里要求的自定义部分加上就完工了，这些花了 $3\sim 4$ 小时。

下午对着 DNS 协议的文档学了 2 小时，看了主要内容，把重要的部分写在 Task2 的笔记里了（包括协议的基础知识和 DNS 报文的组成）。

晚上学了学 Linux dig 和 WireShark 抓包，了解到 WireShark 导出数据包和 DNS 报文都是二进制文件，格式比较相近但有所不同，具体区别还没整明白。大概想了想 DNS 解析器该怎么写。花了 2 小时。