### 10.2

首先我不知道要 C++ 用什么后端框架写服务器端，在 google 上搜了下，好像 crow 框架最受欢迎，就准备用这个。

去官网下 crow，发现解压完不会安装，查了一通发现要 cmake，又查了一通 cmake 怎么用。结果发现自己 linux 上没有 cmake，又去官网下，这样套娃了几层我也忘记了。

终于配置好 crow，看官方 tutorial 写了一个最简单的服务端，能在本机的某个端口整一个网站输出 `hello,world`。

然后想先去完成客户端，一开始想用一些第三方库，但是发现这些很多很小众，看官方文档也很吃力，就想直接用 C++ 自带的 `<sys/socket.h>`，在网上找了很多份最简单的代码，然后对着代码里的函数到官方文档里查使用方法，还是花了挺大劲最终写出了大致符合要求的客户端。

这时候回来写服务端，去查 crow 怎么整 tcp/udp 协议，结果发现这事很困难，crow 是基于 http 协议的框架，很难支持 tcp/udp。很崩溃，于是找了 Boost.Asio 库当后端框架，一顿学，一顿写，中间诸如编译不成功的小麻烦发生了很多。

写完用 tcp 传输的部分后测试了一下，发现客户端与服务端连接上了，可是服务端返回的数据是一团乱码。一度以为是客户端写错了，网上查也查不到相关，调试也不会，走投无路把代码仍给 ChatGPT 调，居然还真调出来了，我在客户端接收和发送数据的时候都是用 `char *data;`，而这样会出错，应当用`char data[100];` 这样的。因为前者只定义指针而没有分配内存空间，导致 send 和 read 发生未定义行为。

最后写好了 TCP 协议传输的部分，但是卡在了不知道在服务端怎么判断 TCP 包还是 UDP 包的问题。自己整了一个骚操作，如果是 UDP 包就先发一个 TCP 包放特定数据表明接下来要发 UDP 包。。太离谱了，问了出题人才知道一般这俩在两个不同端口监听。。准备明天再重构一下代码。

今天大概花了 $7\sim 8$ 个小时学。

### 10.3

一开始在想怎么同时在服务端处理 UDP 和 TCP，但是始终不太能学会用 asio 库来做这个，花了很长时间最后放弃了。后来就干脆不用后端框架了，直接学用 C++ socket 写，结果发现写起来跟客户端差不多，好写多了。再把 Task 里要求的自定义部分加上就完工了，这些花了 $3\sim 4$ 小时。

下午对着 DNS 协议的文档学了 2 小时，看了主要内容，把重要的部分写在 Task2 的笔记里了（包括协议的基础知识和 DNS 报文的组成）。

晚上学了学 Linux dig 和 WireShark 抓包，了解到 WireShark 导出数据包和 DNS 报文都是二进制文件，格式比较相近但有所不同，具体区别还没整明白。大概想了想 DNS 解析器该怎么写。花了 2 小时。

### 10.4

知道了 WireShark 可以直接导出 DNS 报文部分，然后就动手开写解析器。

这一步没什么技术上的难度，就是对着文档上的规则慢慢写。一开始稍微缕了一下思路还挺清晰，后面发现这事工程量不小，写到一些细节的地方发现变量名起的不好影响会特别严重（因为变量实在是太多了），所以代码结构在中间重构了几次。写解析器大约花了 5 个小时才完工，写了快 10kb，但是感觉自己代码实在是太丑了，有想改进的地方但是写到后面改代价太大了，尤其是感觉明明是 C++ 代码我写的更像一个面向过程的，封装得并不是很好。

写 DNS 报文生成器的时候容易些，因为只要处理 A 类型询问报文。写一两个小时完成。

晚上看了看 Task 4，开始时不懂 DNS 报文里在哪里指定查询的域名服务器，后面用 WireShark 抓包对比了一下才发现这东西应该不在报文里，应该是可以发送 UDP 包的时候设置。

同时还学了下如何让多个程序生成一个可执行文件。

### 10.5

今天花的时间少些，Task 4 比想象中顺利很多，因为大部分工作在 Task 1&3 已经完成了，要做的只是把前面 Task 的代码封装好给 Task 4 调用就行。大约一两个小时完成。

晚上看了看 Task 5，一开始连自己要做啥都不太懂，又去搜了很多 DNS 查询相关的资料。发现只有自己去做才能更加了解这些东西的原理。由于还没做 Task 3 的进阶，所以又去查了查 NS 和 CNAME 记录，然后又用 dig 配合 WireShark 抓包看了看从根域名服务器一直查到权威服务器的具体记录，就大概明白了 Task 5 要做的事情，感觉已经会做了。但是还有一些小问题比如怎么让校园网访问自己 53 端口，因为自己电脑 Linux 在虚拟机上，有点麻烦，还不知道怎么处理。